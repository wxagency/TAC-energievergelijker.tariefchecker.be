<?php defined('SVC_HOST') || exit(); define('SVC_CLIENTLIB', '1.5.11'); define('STAMPFORMAT', 'Y-m-d H:i:s'); $slashes = function_exists('preg_match') && preg_match('/%(2f|5c)/i', $_SERVER['QUERY_STRING']); foreach (array_keys($_GET) as $_) if (strlen($_) > 3 && substr($_, 0, 3) !== 'svc' && is_string($_GET[$_])) { if ($slashes) $_GET[$_] = strtr($_GET[$_], array('%2f' => '/', '%2F' => '/', '%5c' => '\\', '%5C' => '\\')); inlineDecode($_GET[$_]); } if ($_POST) foreach (array_keys($_POST) as $_) if (is_string($_POST[$_])) inlineDecode($_POST[$_]); unset($slashes); $flags = isset($_GET['svcflags']) ? (int)$_GET['svcflags'] : 0; $options = svcGlobalOptions(); if ($options['flags'] !== $flags) { $options['flags'] = $flags; svcGlobalOptions($options); } unset($flags, $options); function svcDataQuery($svc = '', $section = '', $params = NULL, $options = NULL, &$cached = NULL) { if (!is_array($options)) $options = array(); $options['gzip'] = isset($options['gzip']) && $options['gzip']; $options['json'] = isset($options['json']) && $options['json']; $options['cacheReload'] = isset($options['cacheReload']) && $options['cacheReload']; $options['cacheTime'] = isset($options['cacheTime']) ? abs((int)$options['cacheTime']) : 300; $options['cacheFile'] = isset($options['cacheFile']) ? (string)$options['cacheFile'] : ''; $options['cacheClean'] = isset($options['cacheClean']) && $options['cacheClean']; $cacheable = $options['cacheTime'] && strlen($options['cacheFile']); $cached = $cacheable && !$options['cacheReload'] && is_file($options['cacheFile']) && filesize($options['cacheFile']) && (filemtime($options['cacheFile']) + $options['cacheTime'] >= time()); if ($cached) { $rawdata = file_get_contents($options['cacheFile']); if (is_string($rawdata) && (($data = svcDataQueryDecode($rawdata, $options['gzip'], $options['json'])) !== FALSE)) { $options['cacheClean'] && @unlink($options['cacheFile']); return $data; } else { @unlink($options['cacheFile']); } } $cached = FALSE; $url = SVC_QDATA.(strlen($svc) ? $svc.'/' : '').(strlen($section) ? $section.(substr($section, -1) === '/' ? '' : '.php') : '').'?'.SVC_QBASE .(is_array($params) && $params ? '&'.http_build_query($params) : (is_string($params) && strlen($params) ? '&'.$params : '')); $rawdata = defined('SVC_USECURL') && SVC_USECURL && curl_setopt($GLOBALS['svcCURL'], CURLOPT_URL, $url) ? curl_exec($GLOBALS['svcCURL']) : @file_get_contents($url, 0, $GLOBALS['svcContext']); if (!is_string($rawdata) || (($data = svcDataQueryDecode($rawdata, $options['gzip'], $options['json'])) === FALSE)) return FALSE; if ($cacheable) if ($options['cacheClean'] || (@file_put_contents($options['cacheFile'], $rawdata, LOCK_EX) !== strlen($rawdata))) if (is_file($options['cacheFile'])) @unlink($options['cacheFile']); return $data; } function svcDataQueryDecode($data, $gzip = TRUE, $json = TRUE) { if (!is_string($data)) return FALSE; if ($gzip) { $data = @gzinflate($data); if (!is_string($data)) return FALSE; } if ($json) { $data = @json_decode($data, TRUE); if ($data === FALSE || $data === NULL) return FALSE; } return $data; } function inlineDecode(&$s) { $pfx = (string)substr($s, 0, 5); if (!$p = strpos($pfx, ':')) return TRUE; $pfx = substr($pfx, 0, $p); switch ($pfx) { case 'B64': $s = base64_decode(substr($s, $p + 1)); return is_string($s); case 'HEX': $s = pack('H*', substr($s, $p + 1)); return is_string($s); case 'JSON': $s = json_decode(substr($s, $p + 1), TRUE); return $s !== NULL; } return TRUE; } function svcGlobalOptions($save = NULL) { $file = './'.SVC_CDIR.'/options'; static $cache; if (is_array($save) && $save) { $cache = $save; return file_put_contents($file, gzdeflate(json_encode($save))) && TRUE; } if ($cache) return $cache; if ( is_file($file) && ($data = file_get_contents($file)) && ($data = gzinflate($data)) && is_array($data = json_decode($data, TRUE)) && isset($data['flags']) ) { $cache = $data; return $data; } $cache = array('flags' => 0); return $cache; } function formatDirName($path, $cDir = './', $rootDir = '/', $strict = FALSE) { $path = strtr(trim($path), '\\', '/'); $drive = ''; if (($_ = strpos($path, ':')) !== FALSE) { $drive = substr($path, 0, $_ + 1); $path = substr($path, $_ + 1); } $root = strlen($path) && $path[0] === '/' ? '/' : ''; $path = explode('/', trim($path, '/')); $ret = array(); foreach ($path as $part) if (strlen($part) && $part !== '.') if ($part === '..' && ($strict || ($ret && end($ret) !== '..'))) array_pop($ret); else $ret[] = $part; $ret = $root.implode('/', $ret); if (!strlen($ret)) return $drive.$cDir; elseif ($ret === '/') return $drive.$rootDir; else return $drive.$ret.'/'; } function splitTextLines($text, $skipEmpty = TRUE, $trimLines = TRUE, $addSplitChars = NULL) { $tr = array("\r" => ''); if (is_string($addSplitChars)) for ($i = 0, $l = strlen($addSplitChars); $i < $l; ++$i) $tr[$addSplitChars[$i]] = "\n"; $textTr = strtr($text, $tr); if (!( $skipEmpty || $trimLines )) return explode("\n", $textTr); $ret = array(); foreach (explode("\n", $textTr) as $v) { if ($trimLines) $v = trim($v); if (!$skipEmpty || strlen($v)) $ret[] = $v; } return $ret; } function removeDir($entry, &$counter = NULL, &$size = NULL, $contentsOnly = FALSE) { if (!strlen($entry)) return FALSE; if (!is_dir($entry) || is_link($entry)) { ++$counter; $size += (float)filesize($entry); return unlink($entry); } $entry .= '/'; if (!$dh = opendir($entry)) return FALSE; $err = FALSE; while (($obj = readdir($dh)) !== FALSE) if ($obj !== '.' && $obj !== '..') if (!removeDir($entry.$obj, $counter, $size, FALSE)) $err = TRUE; closedir($dh); if (!$contentsOnly && !$err) if (!rmdir($entry)) $err = TRUE; return !$err; } function file_safe_rewrite($filename, $data, $lock = FALSE, $context = NULL) { if (!is_string($data)) return FALSE; clearstatcache(); $exists = is_file($filename); if ($exists) { $fmode = (int)fileperms($filename); $backup = $filename.'.tmp'.rand(100, 999); if (!rename($filename, $backup)) return FALSE; } if (file_put_contents($filename, $data, $lock ? LOCK_EX : 0, $context) >= strlen($data)) { if ($exists) { unlink($backup); $fmode && chmod($filename, $fmode); } return TRUE; } else { is_file($filename) && unlink($filename); if ($exists) { rename($backup, $filename); $fmode && chmod($filename, $fmode); } return FALSE; } } function sortFileList($a, $b) { $ad = $a[0][strlen($a[0])-1] === '/'; $bd = $b[0][strlen($b[0])-1] === '/'; if ($ad && $bd) return strcmp($a[0], $b[0]); elseif ($ad) return -1; elseif ($bd) return 1; $_ = strcmp(pathinfo($a[0], PATHINFO_EXTENSION), pathinfo($b[0], PATHINFO_EXTENSION)); if ($_) return $_; else return strcmp($a[0], $b[0]); } function getUserInfo($uid, $part = 'name', $default = '') { if (is_int($uid) && function_exists('posix_getpwuid') && ($user = posix_getpwuid($uid)) && isset($user[$part])) return $user[$part]; return $default; } function getGroupInfo($gid, $part = 'name', $default = '') { if (is_int($gid) && function_exists('posix_getgrgid') && ($group = posix_getgrgid($gid)) && isset($group[$part])) return $group[$part]; return $default; } function shortNumber($num, $precision = 2, $delimiter = ' ', $base = 1024) { $pfx = array('', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'); $num = (float)$num; $pow = $num ? min((int)log(abs($num), $base), count($pfx) - 1) : 0; return round($num / pow($base, $pow), $precision).$delimiter.$pfx[$pow]; } function shortNumberParse($str, $base = 1024) { $str = strtoupper(trim((string)$str)); $num = (float)$str; if (!$num) return $num; $pow = array('K' => 1, 'M' => 2, 'G' => 3, 'T' => 4, 'P' => 5, 'E' => 6, 'Z' => 7, 'Y' => 8); for ($i = strlen($str) - 1; $i >= 0; --$i) if (isset($pow[$str[$i]])) $num *= pow($base, $pow[$str[$i]]); elseif (is_numeric($str[$i])) break; return $num; } class VFS { const version = '1.0.1'; protected $tree; public function __construct(&$tree = NULL) { $this->loadTree($tree); } public function loadTree(&$tree = NULL) { if (is_array($tree)) $this->tree = &$tree; else $this->tree = array(); return $this; } public function loadJSON($treeJSON) { if (!is_string($treeJSON) || strlen($treeJSON) < 2) return FALSE; $tree = json_decode($treeJSON, TRUE); if (!is_array($tree)) return FALSE; $this->tree = $tree; return TRUE; } public function loadFile($file) { return is_string($file) && strlen($file) && is_file($file) && $this->loadJSON(file_get_contents($file)); } public function saveFile($file, $prettyPrint = FALSE) { return is_string($file) && strlen($file) && file_put_contents($file, json_encode($this->tree, self::jsonFlags($prettyPrint))); } public function lookup($path) { if ($this->isEmpty()) return NULL; $t = &$this->tree; foreach (self::explode($path) as $n) { if (!isset($t[$n])) return NULL; $t = &$t[$n]; if (!is_array($t)) return $t; } return $t; } public function sub($path) { $entry = $this->lookup($path); return is_array($entry) ? (new self($entry)) : NULL; } public function isDir($path) { return is_array($this->lookup($path)); } public function isFile($path) { $entry = $this->lookup($path); return $entry !== NULL && !is_array($entry); } public function isEmpty() { return empty($this->tree); } public function exists($path) { if ($this->isEmpty()) return FALSE; $t = &$this->tree; foreach (self::explode($path) as $n) { if (!isset($t[$n])) return FALSE; $t = &$t[$n]; if (!is_array($t)) return TRUE; } return TRUE; } public function scandir($path) { $t = $this->lookup($path); if (!is_array($t)) return FALSE; return array_keys($t); } public function add($path, $entry = NULL) { $p = self::explode($path); if (empty($p)) return $this; $baseName = array_pop($p); $t = &$this->tree; foreach ($p as $n) { if (!isset($t[$n]) || !is_array($t[$n])) $t[$n] = array(); $t = &$t[$n]; } $t[$baseName] = $entry; return $this; } public function del($path) { $p = self::explode($path); if (empty($p)) return $this; $baseName = array_pop($p); $t = &$this->tree; foreach ($p as $n) { if (!isset($t[$n]) || !is_array($t[$n])) return $this; $t = &$t[$n]; } unset($t[$baseName]); return $this; } public function lookup2($path, &$baseName = NULL) { $p = self::explode($path); if (empty($p)) return NULL; $baseName = array_pop($p); return $this->lookup($p); } public function dump($wrap = 1) { if ($wrap & 2) echo "<pre>"; echo json_encode($this->tree, self::jsonFlags(TRUE)); if ($wrap & 2) echo "</pre>"; if ($wrap & 1) echo "\n"; return $this; } public static function jsonFlags($prettyPrint) { $flags = $prettyPrint ? JSON_PRETTY_PRINT : 0; return defined('JSON_UNESCAPED_SLASHES') ? $flags|JSON_UNESCAPED_SLASHES|JSON_UNESCAPED_UNICODE : $flags; } public static function explode($path) { if (is_array($path)) return $path; if (!is_string($path)) return array(); $trim = trim($path, '/'); if (!strlen($trim)) return array(); return explode('/', $trim); } public static function implode($path) { if (is_array($path)) return $path ? trim(implode('/', $path), '/') : ''; if (is_string($path)) return trim($path, '/'); return ''; } } function dirSize($path) { $dir = !strlen($path) ? './' : ($path[strlen($path)-1] !== '/' ? $path.'/' : $path); $size = 0.0; if (!$h = opendir($dir)) return $size; while (($f = readdir($h)) !== FALSE) if ($f !== '.' && $f !== '..') { $df = $dir.$f; $size += is_dir($df) && !is_link($df) ? dirSize($df.'/') : (float)filesize($df); } closedir($h); return $size; } function scanDirEx($path, $deepSize = FALSE) { $dir = !strlen($path) ? './' : ($path[strlen($path)-1] !== '/' ? $path.'/' : $path); if (!$h = opendir($dir)) return FALSE; $list = array(); while (($f = readdir($h)) !== FALSE) { $df = $dir.$f; if ($f === '.' || $f === '..') { $f .= '/'; $size = 0.0; } elseif (is_dir($df) && !is_link($df)) { $f .= '/'; $size = $deepSize ? dirSize($df.'/') : 0.0; } else { $size = (float)filesize($df); } $list[] = array($f, $size, filemtime($df), fileperms($df), getUserInfo(fileowner($df)), getGroupInfo(filegroup($df)), (is_readable($df) ? '' : 'R').(is_writable($df) ? '' : 'W')); } closedir($h); return $list; } function scanDirSplit($path, &$list, $split = 0.0, $pcre = '', &$ignored = array(), $snapShot = NULL) { $dir = !strlen($path) ? '' : ($path[strlen($path)-1] !== '/' ? $path.'/' : $path); if (!$h = opendir(strlen($dir) ? $dir : '.')) return FALSE; $csize = array(0.0, 0.0, 0.0); $clist = array(); while (($f = readdir($h)) !== FALSE) if ($f !== '.' && $f !== '..' && !is_link($df = $dir.$f)) { if (is_dir($df)) { $df .= '/'; if ($ignored && isset($ignored[$df])) continue; $sizes = scanDirSplit($df, $list, $split, $pcre, $ignored, $snapShot); if (!is_array($sizes)) $sizes = array(0.0, 0.0, 0.0); $clist[] = array($df, $sizes); $csize[0] += $sizes[0]; $csize[2] += $sizes[2]; } else { if ($ignored && isset($ignored[$df]) || $pcre && !preg_match($pcre, $f)) continue; $fsize = (float)filesize($df); $csize[0] += $fsize; $csize[1] += $fsize; if ($snapShot) { $prev = $snapShot->lookup($df); if (is_string($prev)) { $ftime = filemtime($df); if ($prev === "s$fsize;m$ftime") continue; } } $csize[2] += $fsize; } } if ($csize[2] > $split) foreach ($clist as $citem) $list[] = array($citem[0], ($citem[1][2] > $split) ? $citem[1][1] : $citem[1][0], filemtime($citem[0]), fileperms($citem[0]), '', '', (is_readable($citem[0]) ? '' : 'R').(is_writable($citem[0]) ? '' : 'W').($citem[1][2] > $split ? 'S' : '')); closedir($h); return $csize; } set_time_limit(300); $dir = formatDirName(isset($_GET['filedirname']) ? $_GET['filedirname'] : ''); if (!is_dir($dir)) return ERR_SVC + 0; $subDirs = isset($_GET['subdirs']) ? abs((int)$_GET['subdirs']) : 0; $split = isset($_GET['splitsize']) ? abs(shortNumberParse($_GET['splitsize'])) : 0; $pcre = isset($_GET['pcre']) ? trim($_GET['pcre']) : ''; if ($pcre === 'default') $pcre = ''; $snapShot = NULL; if ($subDirs < 2) { $list = @scanDirEx($dir, $subDirs > 0); if (!is_array($list)) return ERR_SVC + 1; } else { if (isset($_GET['fulllist'])) { $ignored = array(); } else { $ignored = svcDataQuery('', 'ignored', array(), array( 'gzip' => SVC_CGZIP, 'json' => TRUE, 'cacheFile' => SVC_CCACHE.'/ignored.json', 'cacheClean' => SVC_CLC, )); if (!is_array($ignored)) return ERR_SVC + 2; $ignored = array_flip($ignored); } if (isset($_GET['snapshot'])) { $snapShot = new VFS(); $snapShot->loadFile(SVC_CCACHE.'/snapshot.json'); if ($snapShot->isEmpty()) $snapShot = NULL; } $list = array(); $sizes = @scanDirSplit($dir === './' ? '' : $dir, $list, $split, $pcre, $ignored, $snapShot); if (!is_array($sizes)) return ERR_SVC + 1; $list[] = @array($dir, ($sizes[2] > $split) ? $sizes[1] : $sizes[0], filemtime($dir), fileperms($dir), '', '', (is_readable($dir) ? '' : 'R').(is_writable($dir) ? '' : 'W').($sizes[2] > $split ? 'S' : '')); } usort($list, 'sortFileList'); for ($i = 0, $c = count($list); $i < $c; ++$i) if (!preg_match('//u', $list[$i][0])) $list[$i][0] = 'B64:'.base64_encode($list[$i][0]); echo json_encode($list); ?>